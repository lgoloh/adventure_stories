


 15//Utility functions:                                                                                   
 16size_t getPageNum(string & str_num) {
 17  const char * str = str_num.c_str();
 18  size_t len_initwhitespaces = strspn(str, " \t");
 19  char * rem_str = strdup(str + len_initwhitespaces);
 20
 21  for (size_t i = 0; i < str_num.size(); i++) {
 22    if (!isdigit(rem_str[i])) {
 23      throw std::invalid_argument("invalid page number\n");
 24    }
 25  }
 26  size_t pg_num = strtoull(rem_str, NULL, 10);
 27  free(rem_str);
 28  return pg_num;
 29}
 30
 31//Splits string by a delimiter and returns a pair of the key and value                                 
 32std::pair<string, string> splitStrByDelim(const string & str, const string & delim) {
 33  size_t delim_pos = str.find_first_of(delim);
 34  if (delim_pos == string::npos) {
 35    throw std::invalid_argument("Invalid argument: no delimeter\n");
 36  }
 37  return make_pair(str.substr(0, delim_pos), str.substr(delim_pos + 1));
 38}

 40/*                                                                                                     
 41 * Parses a page declaration if its valid                                                              
 42 * Returns a tuple of the page number, page type and page file name                                    
 43 */
 44tuple<size_t, Pagetype, string> parsePageDeclaration(string & line, const string & path) {
 45  size_t page_num = 0;
 46  Pagetype page_type;
 47  string page_file = "";
 48
 49  try {
 50    std::pair<string, string> init_split = splitStrByDelim(line, "@");
 51    page_num = getPageNum(init_split.first);
 52    std::pair<string, string> type_split = splitStrByDelim(init_split.second, ":");
 53    page_type = strToPagetype(type_split.first);
 54    page_file = string(path).append("/").append(type_split.second);
 55    if (page_file.size() == 0) {
 56      throw std::invalid_argument("Invalid argument: empty file name\n");
 57    }
 58  }
 59  catch (std::invalid_argument & error) {
 60    cerr << "Invalid page declaration: " << line << error.what() << std::endl;
 61    exit(EXIT_FAILURE);
 62  }
 63
 64  return tuple<size_t, Pagetype, string>(page_num, page_type, page_file);
 65}


 67/*                                                                                                     
 68 * Parses a valid choice declaration                                                                   
 69 * return: tuple of source page, destination page and the choice text                                  
 70 */
 71tuple<string, size_t, string> parseChoiceDeclaration(string line) {
 72  string source = "";
 73  size_t dest = 0;
 74  string text = "";
 75
 76  try {
 77    std::pair<string, string> init = splitStrByDelim(line, ":");
 78    source = init.first;
 79    std::pair<string, string> nxt = splitStrByDelim(init.second, ":");
 80    dest = getPageNum(nxt.first);
 81    text = nxt.second;
 82    if (text.size() == 0) {
 83      throw std::invalid_argument("Invalid argument: empty choice text\n");
 84    }
 85  }
 86  catch (std::invalid_argument & error) {
 87    cerr << "Invalid choice declaration: " << line << std::endl;
 88    exit(EXIT_FAILURE);
 89  }
 90
 91  return tuple<string, size_t, string>(source, dest, text);
 92}
 93
 94/*                                                                                                     
 95 * Parses a varibale declaration                                                                       
 96 * return: tuple of page number, variable name, and value                                              
 97 */
 98tuple<size_t, string, long> parseVarDeclaration(string line) {
 99  size_t source = 0;
100  string var_name = "";
101  long val;
102
103  try {
104    std::pair<string, string> init = splitStrByDelim(line, "$");
105    source = getPageNum(init.first);
106    std::pair<string, string> nxt = splitStrByDelim(init.second, "=");
107    var_name = nxt.first;
108    val = atol(nxt.second.c_str());
109  }
110  catch (std::invalid_argument & error) {
111    cerr << "Invalid choice declaration: " << line << std::endl;
112    exit(EXIT_FAILURE);
113  }
114
115  return tuple<size_t, string, long>(source, var_name, val);
116}
117

118/*                                                                                                    
119 * Verifies that the pages are in order                                                               
120 * return: true if pages are consective and first page is 0, false otherwise                          
121 */
122bool isMissingPages(Story * story, size_t page_num) {
123  if (story->getPages().size() == 0) {
124    return (page_num == 0) ? false : true;
125  }
126  else {
127    size_t last_pg = story->getPages().back()->getPageNumber();
128    return ((page_num - last_pg) == 1) ? false : true;
129  }
130}

131/*                                                                                                    
132 * Parses a choice condition                                                                          
133 * returns: tuple of page number, variable name, value                                                
134 */
135tuple<size_t, string, long> parseChoiceCond(string line) {
136  size_t source = 0;
137  string var_name = "";
138  long val;
139
140  try {
141    std::pair<string, string> init = splitStrByDelim(line, "[");
142    source = getPageNum(init.first);
143    std::pair<string, string> nxt = splitStrByDelim(init.second, "=");
144    var_name = nxt.first;
145    std::pair<string, string> fin = splitStrByDelim(nxt.second, "]");
146    val = atol(fin.first.c_str());
147  }
148  catch (std::invalid_argument & error) {
149    cerr << "Invalid choice declaration: " << line << std::endl;
150    exit(EXIT_FAILURE);
151  }
152
153  return tuple<size_t, string, long>(source, var_name, val);
154}

/*
 * Creates a new page
 * return: Page pointer
 */
Page * createPage(string line, string dir, Story * story) {
  tuple<size_t, Pagetype, string> page_metadata = parsePageDeclaration(line, dir);

  if (isMissingPages(story, page_metadata.first())) {
    throw std::invalid_argument("Out of order page\n");
  }
  else {
    return new Page(page_metadata.first(), page_metadata.second(), page_metadata.third());
  }
}


/*                                                                                                    * Creates a new condition                                                                            * return: Choice pointerx                                                                            */
Choice * createChoice(string line) {
    tuple<string, size_t, string> choice_metadata = parseChoiceDeclaration(line);
    string ch_src = choice_metadata.first();
    if (ch_src.find("[") != string::npos) {
        tuple<size_t, string, long> cond = parseChoiceCond(ch_src);
    return new ConditionalChoice(cond.first(),
					choice_metadata.second()
					choice_metadata.third(),
					cond.second(),
					cond.third());
      }
    else {
        size_t pg_num = getPageNum(ch_src);
        return new Choice(pg_num, choice_metadata.second(), choice_metadata.third());
    }
}


/*                                                                                                    * Parses the story metadata in story.txt and creates a story object                                  */
Story * createStory(string & storyDir) {
  string story_path = string(storyDir).append("/story.txt");
  ifstream story_mtdt;
  story_mtdt.open(story_path.c_str(), ifstream::in);
  if (!story_mtdt.is_open()) {
    std::cerr << "Error opening file\n" << story_path << std::endl;
    exit(EXIT_FAILURE);
  }

  Story * story = new Story();
  string cur_line;
  while (std::getline(story_mtdt, cur_line)) {
    if (cur_line.size() == 0) {
      continue;
    }
 
    if (cur_line.find("@") != string::npos) {
      Page * new_page = createPage(cur_line, storyDir, story);
      story->addPage(new_page);
    }
    else if (cur_line.find("$") != string::npos) {
      tuple<size_t, string, long> var = parseVarDeclaration(cur_line);
      Page * pg = story->getPage(var.first());
      if (pg == NULL) {
        throw std::invalid_argument("Invalid page for variable declaration\n");
      }
      else {
        pg->addVar(var.second(), var.third());
        story->addVar(var.second(), 0);
      }
    }
    else {
      Choice * ch = createChoice(cur_line);
      Page * pg = story->getPage(ch->getSource());
      if (pg == NULL || (pg->isWinPage() || pg->isLosePage())) {
        throw std::invalid_argument("Invalid page for choice\n");
      }
      else {
        pg->addChoice(ch);
        story->updateRefsForPage(ch->getSource(), ch->getDest());
      }
    }
  }
  story_mtdt.close();
  return story;
}
